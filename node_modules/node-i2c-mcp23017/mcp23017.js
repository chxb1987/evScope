
var i2c = require('i2c-bus'),
i2c1 = i2c.openSync(1);
//
var Gpio = require('onoff').Gpio
var button;
INPUT= 0x0
OUTPUT=0x1

HIGH=0x1
LOW=0x0

CHANGE= 1
FALLING=2
RISING= 3

MCP23017_ADDRESS= 0x20

MCP23017_IODIRA = 0x00
MCP23017_IPOLA = 0x02
MCP23017_GPINTENA = 0x04
MCP23017_DEFVALA = 0x06
MCP23017_INTCONA = 0x08
MCP23017_IOCONA = 0x0A
MCP23017_GPPUA = 0x0C
MCP23017_INTFA = 0x0E
MCP23017_INTCAPA = 0x10
MCP23017_GPIOA = 0x12
MCP23017_OLATA = 0x14


MCP23017_IODIRB = 0x01
MCP23017_IPOLB = 0x03
MCP23017_GPINTENB = 0x05
MCP23017_DEFVALB = 0x07
MCP23017_INTCONB = 0x09
MCP23017_IOCONB = 0x0B
MCP23017_GPPUB = 0x0D
MCP23017_INTFB = 0x0F
MCP23017_INTCAPB = 0x11
MCP23017_GPIOB = 0x13
MCP23017_OLATB = 0x15

MCP23017_INT_ERR= 255 ;

var MCP23017= function(icAddress,raspPin) {
  this.icAddress=icAddress;
  this.begin(icAddress);
  this.interruptCallback=null;

  this.setupInterrupts(true,false,LOW)

  for(var i=0;i<8;i++){
    // this.pinMode(i,INPUT);       // already set in begin fucntion
    this.pullUp(i,HIGH)
    // this.digitalWrite(8+i,LOW)
    this.setupInterruptPin(i,FALLING)
  }

  this.button = new Gpio(raspPin, 'in','falling');

  // button.setEdge('falling')
  var temp=this;
  this.button.watch( function(err, value) {
    if (err) {
      throw err;
    }  if(value==0){
      pin=temp.getLastInterruptPin();
      val=temp.getLastInterruptPinValue();

      while( ! (temp.digitalRead(pin) ));
      if(temp.interruptCallback!=null){
        temp.interruptCallback(pin,temp.icAddress);
      }
    }
    // led.writeSync(value);
  });
}

MCP23017.prototype.setInterruptCallback=function(x){
  this.interruptCallback=x;
}

bitRead=function(value, bit) {
  value=((value) >> (bit)) & 0x01
  return value
  // console.log("Read")
}
bitSet=function(value, bit) {
  value |= 1 << bit
  return value
}
bitClear=function(value, bit) {
  value &= ~(1 << bit)
  return value
}
bitWrite=function(value, bit, bitvalue){
  value= bitvalue ? bitSet(value, bit) : bitClear(value, bit)
  return value
}

/**
* Bit number associated to a give Pin
*/

bitForPin=function(pin){
  return pin%8
}

/**
* Register address, port dependent, for a given PIN
*/

regForPin=function(pin,portAaddr,portBaddr){
  return pin<8?portAaddr:portBaddr
}

/**
* Reads a given register
*/
MCP23017.prototype.readRegister=function(addr){
  recv=i2c1.readByteSync(MCP23017_ADDRESS|this.icAddress, addr)
  return recv

}

/**
* Writes a given register
*/
MCP23017.prototype.writeRegister=function(regAddr,regValue){
  i2c1.writeByteSync(MCP23017_ADDRESS|this.icAddress, regAddr, regValue)
}

/**
* Helper to update a single bit of an A/B register.
* - Reads the current register value
* - Writes the new register value
*/
MCP23017.prototype.updateRegisterBit=function( pin,  pValue,  portAaddr,  portBaddr) {
  regAddr=regForPin(pin,portAaddr,portBaddr);
  bit=bitForPin(pin);
  regValue = this.readRegister(regAddr);
  // set the value for the particular bit
  regValue=bitWrite(regValue,bit,pValue);
  this.writeRegister(regAddr,regValue);
}
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
/**
* Initializes the MCP23017 given its HW selected address, see datasheet for Address selection.
*/
MCP23017.prototype.begin=function(addr){
  if (addr > 7) {
    addr = 7;
  }
  this.icAddress = addr;
  // this.raspPin=raspPin;

  // set defaults!
  // all inputs on port A
  this.writeRegister(MCP23017_IODIRA,0xff);
  // all output on port B
  this.writeRegister(MCP23017_IODIRB,0x00);
}

/**
* Sets the pin mode to either INPUT or OUTPUT
*/
MCP23017.prototype.icAddress=function( ) {
return this.icAddress;

}

/**
* Sets the pin mode to either INPUT or OUTPUT
*/
MCP23017.prototype.pinMode=function( p,  d) {
  this.updateRegisterBit(p,(d==INPUT),MCP23017_IODIRA,MCP23017_IODIRB);
}

MCP23017.prototype.digitalWrite=function( pin,  d) {

  bit=bitForPin(pin);
  // read the current GPIO output latches
  regAddr=regForPin(pin,MCP23017_OLATA,MCP23017_OLATB);
  gpio = this.readRegister(regAddr);

  // set the pin and direction
  gpio =bitWrite(gpio,bit,d);

  // write the new GPIO
  regAddr=regForPin(pin,MCP23017_GPIOA,MCP23017_GPIOB);
  this.writeRegister(regAddr,gpio);
}

MCP23017.prototype.pullUp=function( p,  d) {
  this.updateRegisterBit(p,d,MCP23017_GPPUA,MCP23017_GPPUB);
}

MCP23017.prototype.digitalRead=function( pin) {
  bit=bitForPin(pin);
  regAddr=regForPin(pin,MCP23017_GPIOA,MCP23017_GPIOB);
  return (this.readRegister(regAddr) >> bit) & 0x1;
}

/**
* Configures the interrupt system. both port A and B are assigned the same configuration.
* Mirroring will OR both INTA and INTB pins.
* Opendrain will set the INT pin to value or open drain.
* polarity will set LOW or HIGH on interrupt.
* Default values after Power On Reset are: (false,flase, LOW)
* If you are connecting the INTA/B pin to arduino 2/3, you should configure the interupt handling as FALLING with
* the default configuration.
*/

MCP23017.prototype.setupInterrupts=function( mirroring,  openDrain,  polarity){
  // configure the port A
  ioconfValue=this.readRegister(MCP23017_IOCONA);
  ioconfValue=bitWrite(ioconfValue,6,mirroring);
  ioconfValue=	bitWrite(ioconfValue,2,openDrain);
  ioconfValue=bitWrite(ioconfValue,1,polarity);
  this.writeRegister(MCP23017_IOCONA,ioconfValue);

  // Configure the port B
  ioconfValue=this.readRegister(MCP23017_IOCONB);
  ioconfValue=bitWrite(ioconfValue,6,mirroring);
  ioconfValue=bitWrite(ioconfValue,2,openDrain);
  ioconfValue=bitWrite(ioconfValue,1,polarity);
  this.writeRegister(MCP23017_IOCONB,ioconfValue);
}

/**
* Set's up a pin for interrupt. uses arduino MODEs: CHANGE, FALLING, RISING.
*
* Note that the interrupt condition finishes when you read the information about the port / value
* that caused the interrupt or you read the port itself. Check the datasheet can be confusing.
*
*/
MCP23017.prototype.setupInterruptPin=function( pin,  mode) {

  // set the pin interrupt control (0 means change, 1 means compare against given value);
  this.updateRegisterBit(pin,(mode!=CHANGE),MCP23017_INTCONA,MCP23017_INTCONB);
  // if the mode is not CHANGE, we need to set up a default value, different value triggers interrupt

  // In a RISING interrupt the default value is 0, interrupt is triggered when the pin goes to 1.
  // In a FALLING interrupt the default value is 1, interrupt is triggered when pin goes to 0.
  this.updateRegisterBit(pin,(mode==FALLING),MCP23017_DEFVALA,MCP23017_DEFVALB);

  // enable the pin for interrupt
  this.updateRegisterBit(pin,HIGH,MCP23017_GPINTENA,MCP23017_GPINTENB);


}

MCP23017.prototype.getLastInterruptPin=function(){
  // try port A
  intf=this.readRegister(MCP23017_INTFA);
  for(var  i=0;i<8;i++) if (bitRead(intf,i)) return i;
  // console.log("Here")
  // try port B
  intf=this.readRegister(MCP23017_INTFB);
  for(var i=0;i<8;i++) if (bitRead(intf,i)) return i+8;

  return MCP23017_INT_ERR;

}
MCP23017.prototype.getLastInterruptPinValue=function(){
  intPin=this.getLastInterruptPin();
  if(intPin!=MCP23017_INT_ERR){
    intcapreg=regForPin(intPin,MCP23017_INTCAPA,MCP23017_INTCAPB);
    bit=bitForPin(intPin);
    return (this.readRegister(intcapreg)>>bit) & (0x01);
  }

  return MCP23017_INT_ERR;
}

// mcpPinA=0
// raspiPin=15
// button = new Gpio(raspiPin, 'in','falling')
// // button.setEdge('falling')
// button.watch(function (err, value) {
//   if (err) {
//     throw err;
//   }
//   console.log(button.edge())
//
//   pin=getLastInterruptPin();
//   val=getLastInterruptPinValue();
//   console.log("Interrupt Value",value)
//   console.log("Interrupt Called val ",val)
//   console.log("Interrupt Called pin ",pin)
//   while( ! (digitalRead(mcpPinA) ));
//   // and clean queued INT signal
//
//
//   // led.writeSync(value);
// });






module.exports = MCP23017;

// var mcp=new MCP23017();
// mcp.begin(0);
// mcp.pinMode(8,OUTPUT)
// mcp.digitalWrite(8,LOW)
